diff --git a/configure b/configure
index 732de59..ab6d1f8 100755
--- a/configure
+++ b/configure
@@ -290,6 +290,7 @@ External library support:
   --enable-libv4l2         enable libv4l2/v4l-utils [no]
   --enable-libvidstab      enable video stabilization using vid.stab [no]
   --enable-libvmaf         enable vmaf filter via libvmaf [no]
+  --enable-libvmaf-vulkan  enable Vulkan-accelerated vmaf filter via libvmaf [no]
   --enable-libvo-amrwbenc  enable AMR-WB encoding via libvo-amrwbenc [no]
   --enable-libvorbis       enable Vorbis en/decoding via libvorbis,
                            native implementation exists [no]
@@ -1987,6 +1988,7 @@ EXTERNAL_LIBRARY_LIST="
     libuavs3d
     libv4l2
     libvmaf
+    libvmaf_vulkan
     libvorbis
     libvpx
     libvvenc
@@ -4063,6 +4065,7 @@ vidstabdetect_filter_deps="libvidstab"
 vidstabtransform_filter_deps="libvidstab"
 libvmaf_filter_deps="libvmaf"
 libvmaf_cuda_filter_deps="libvmaf libvmaf_cuda ffnvcodec"
+libvmaf_vulkan_filter_deps="libvmaf libvmaf_vulkan vulkan"
 zmq_filter_deps="libzmq"
 zoompan_filter_deps="swscale"
 zscale_filter_deps="libzimg const_nan"
@@ -7163,6 +7166,8 @@ enabled libv4l2           && require_pkg_config libv4l2 libv4l2 libv4l2.h v4l2_i
 enabled libvidstab        && require_pkg_config libvidstab "vidstab >= 0.98" vid.stab/libvidstab.h vsMotionDetectInit
 enabled libvmaf           && require_pkg_config libvmaf "libvmaf >= 2.0.0" libvmaf.h vmaf_init
 enabled libvmaf           && check_pkg_config libvmaf_cuda "libvmaf >= 2.0.0" libvmaf_cuda.h vmaf_cuda_state_init
+enabled libvmaf_vulkan    && require_pkg_config libvmaf "libvmaf >= 2.0.0" libvmaf.h vmaf_init &&
+                             check_pkg_config libvmaf_vulkan "libvmaf >= 2.0.0" libvmaf_vulkan.h vmaf_vulkan_state_init
 enabled libvo_amrwbenc    && require libvo_amrwbenc vo-amrwbenc/enc_if.h E_IF_init -lvo-amrwbenc
 enabled libvorbis         && require_pkg_config libvorbis vorbis vorbis/codec.h vorbis_info_init &&
                              require_pkg_config libvorbisenc vorbisenc vorbis/vorbisenc.h vorbis_encode_init
diff --git a/libavfilter/Makefile b/libavfilter/Makefile
index 07fb4c3..0ea63d9 100644
--- a/libavfilter/Makefile
+++ b/libavfilter/Makefile
@@ -374,6 +374,7 @@ OBJS-$(CONFIG_LENSFUN_FILTER)                += vf_lensfun.o
 OBJS-$(CONFIG_LIBPLACEBO_FILTER)             += vf_libplacebo.o vulkan.o vulkan_filter.o
 OBJS-$(CONFIG_LIBVMAF_FILTER)                += vf_libvmaf.o framesync.o
 OBJS-$(CONFIG_LIBVMAF_CUDA_FILTER)           += vf_libvmaf.o framesync.o
+OBJS-$(CONFIG_LIBVMAF_VULKAN_FILTER)         += vf_libvmaf.o framesync.o
 OBJS-$(CONFIG_LIMITDIFF_FILTER)              += vf_limitdiff.o framesync.o
 OBJS-$(CONFIG_LIMITER_FILTER)                += vf_limiter.o
 OBJS-$(CONFIG_LOOP_FILTER)                   += f_loop.o
diff --git a/libavfilter/allfilters.c b/libavfilter/allfilters.c
index cca4ce0..c03601f 100644
--- a/libavfilter/allfilters.c
+++ b/libavfilter/allfilters.c
@@ -348,6 +348,7 @@ extern const FFFilter ff_vf_lensfun;
 extern const FFFilter ff_vf_libplacebo;
 extern const FFFilter ff_vf_libvmaf;
 extern const FFFilter ff_vf_libvmaf_cuda;
+extern const FFFilter ff_vf_libvmaf_vulkan;
 extern const FFFilter ff_vf_limitdiff;
 extern const FFFilter ff_vf_limiter;
 extern const FFFilter ff_vf_loop;
diff --git a/libavfilter/vf_libvmaf.c b/libavfilter/vf_libvmaf.c
index 10d5b7f..ed2a209 100644
--- a/libavfilter/vf_libvmaf.c
+++ b/libavfilter/vf_libvmaf.c
@@ -46,6 +46,14 @@
 #include "libavutil/hwcontext_cuda_internal.h"
 #endif
 
+#if CONFIG_LIBVMAF_VULKAN_FILTER
+#include <inttypes.h>
+#include <libvmaf/libvmaf_vulkan.h>
+#include "libavutil/hwcontext.h"
+#include "libavutil/hwcontext_vulkan.h"
+#include "libavutil/vulkan_functions.h"
+#include "libavutil/vulkan_loader.h"
+#endif
+
 typedef struct LIBVMAFContext {
     const AVClass *class;
     FFFrameSync fs;
@@ -64,6 +72,20 @@ typedef struct LIBVMAFContext {
 #if CONFIG_LIBVMAF_CUDA_FILTER
     VmafCudaState *cu_state;
 #endif
+#if CONFIG_LIBVMAF_VULKAN_FILTER
+    VmafVulkanState *vk_state;
+    FFVulkanFunctions vkfn;
+    VkDevice vk_device;
+    VkQueue vk_queue;
+    VkBuffer vmaf_ref_buf;
+    VkBuffer vmaf_dist_buf;
+    VkCommandPool copy_pool;
+    VkCommandBuffer copy_cmd;
+    VkImageAspectFlags y_plane_aspect;
+    unsigned pixel_shift;
+    int gpu_profile;
+#endif
 } LIBVMAFContext;
 
 #define OFFSET(x) offsetof(LIBVMAFContext, x)
@@ -826,3 +848,414 @@ const FFFilter ff_vf_libvmaf_cuda = {
     .flags_internal = FF_FILTER_FLAG_HWFRAME_AWARE,
 };
 #endif
+
+#if CONFIG_LIBVMAF_VULKAN_FILTER
+
+#define VULKAN_FLAGS AV_OPT_FLAG_FILTERING_PARAM|AV_OPT_FLAG_VIDEO_PARAM
+static const AVOption libvmaf_vulkan_options[] = {
+    {"log_path",  "Set the file path to be used to write log.",
+                  OFFSET(log_path), AV_OPT_TYPE_STRING, {.str=NULL}, 0, 1, VULKAN_FLAGS},
+    {"log_fmt",   "Set the format of the log (csv, json, xml, or sub).",
+                  OFFSET(log_fmt), AV_OPT_TYPE_STRING, {.str="xml"}, 0, 1, VULKAN_FLAGS},
+    {"pool",      "Set the pool method to be used for computing vmaf.",
+                  OFFSET(pool), AV_OPT_TYPE_STRING, {.str=NULL}, 0, 1, VULKAN_FLAGS},
+    {"n_threads", "Set number of threads to be used when computing vmaf.",
+                  OFFSET(n_threads), AV_OPT_TYPE_INT, {.i64=0}, 0, UINT_MAX, VULKAN_FLAGS},
+    {"n_subsample", "Set interval for frame subsampling used when computing vmaf.",
+                    OFFSET(n_subsample), AV_OPT_TYPE_INT, {.i64=1}, 1, UINT_MAX, VULKAN_FLAGS},
+    {"model",     "Set the model to be used for computing vmaf.",
+                  OFFSET(model_cfg), AV_OPT_TYPE_STRING, {.str="version=vmaf_v0.6.1"}, 0, 1, VULKAN_FLAGS},
+    {"feature",   "Set the feature to be used for computing vmaf.",
+                  OFFSET(feature_cfg), AV_OPT_TYPE_STRING, {.str=NULL}, 0, 1, VULKAN_FLAGS},
+    {"gpu_profile", "Print per-shader GPU timing breakdown at end of encode.",
+                    OFFSET(gpu_profile), AV_OPT_TYPE_BOOL, {.i64=0}, 0, 1, VULKAN_FLAGS},
+    { NULL }
+};
+#undef VULKAN_FLAGS
+FRAMESYNC_DEFINE_CLASS(libvmaf_vulkan, LIBVMAFContext, fs);
+
+static int do_vmaf_vulkan(FFFrameSync *fs)
+{
+    AVFilterContext *ctx = fs->parent;
+    LIBVMAFContext *s = ctx->priv;
+    FFVulkanFunctions *vk = &s->vkfn;
+    AVFrame *ref, *dist;
+    AVVkFrame *ref_vk, *dist_vk;
+    VkResult vr;
+    int ret;
+
+    ret = ff_framesync_dualinput_get(fs, &dist, &ref);
+    if (ret < 0)
+        return ret;
+    if (ctx->is_disabled || !ref)
+        return ff_filter_frame(ctx->outputs[0], dist);
+
+    ref_vk  = (AVVkFrame *)ref->data[0];
+    dist_vk = (AVVkFrame *)dist->data[0];
+
+    // Determine correct image aspect for the Y (luma) plane.
+    // For multi-planar VkImages (e.g. G8_B8_R8_3PLANE_420_UNORM when
+    // hwupload creates a single VkImage), we must use PLANE_0_BIT.
+    // For separate per-plane VkImages (R8_UNORM each), use COLOR_BIT.
+    VkImageAspectFlags y_aspect = s->y_plane_aspect;
+
+    // First-frame diagnostic dump
+    if (s->frame_cnt == 0) {
+        av_log(ctx, AV_LOG_INFO,
+               "libvmaf_vulkan frame 0: ref img=%p layout=0x%x access=0x%x "
+               "sem_value=%"PRIu64" | dist img=%p layout=0x%x access=0x%x "
+               "sem_value=%"PRIu64" | aspect=0x%x\n",
+               (void *)ref_vk->img[0], ref_vk->layout[0], ref_vk->access[0],
+               ref_vk->sem_value[0],
+               (void *)dist_vk->img[0], dist_vk->layout[0], dist_vk->access[0],
+               dist_vk->sem_value[0],
+               y_aspect);
+    }
+
+    // Wait for previous libvmaf compute batch to finish reading from the
+    // shared buffers before we overwrite them with new frame data.
+    // Without this, the vkCmdCopyImageToBuffer below can race with the
+    // previous frame's compute shaders on the same queue.
+    ret = vmaf_vulkan_wait_compute(s->vmaf);
+    if (ret) {
+        av_log(ctx, AV_LOG_ERROR,
+               "vmaf_vulkan_wait_compute failed: %d\n", ret);
+        return AVERROR_EXTERNAL;
+    }
+
+    // Record Y-plane copies: VkImage -> libvmaf shared VkBuffers
+    VkCommandBufferBeginInfo begin_info = {
+        .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,
+        .flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT,
+    };
+    vk->BeginCommandBuffer(s->copy_cmd, &begin_info);
+
+    // Transition both Y-plane images to TRANSFER_SRC_OPTIMAL.
+    // Timeline semaphores (below) provide execution+memory dependency from
+    // the decoder, so srcStageMask only needs layout transition coverage.
+    VkImageMemoryBarrier img_barriers[2] = {
+        {
+            .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
+            .srcAccessMask = 0,  // semaphore covers memory dependency
+            .dstAccessMask = VK_ACCESS_TRANSFER_READ_BIT,
+            .oldLayout     = ref_vk->layout[0],
+            .newLayout     = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
+            .srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
+            .dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
+            .image = ref_vk->img[0],
+            .subresourceRange = {
+                y_aspect, 0, 1, 0, 1
+            },
+        },
+        {
+            .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
+            .srcAccessMask = 0,  // semaphore covers memory dependency
+            .dstAccessMask = VK_ACCESS_TRANSFER_READ_BIT,
+            .oldLayout     = dist_vk->layout[0],
+            .newLayout     = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
+            .srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
+            .dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
+            .image = dist_vk->img[0],
+            .subresourceRange = {
+                y_aspect, 0, 1, 0, 1
+            },
+        },
+    };
+    vk->CmdPipelineBarrier(s->copy_cmd,
+                         VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
+                         VK_PIPELINE_STAGE_TRANSFER_BIT,
+                         0, 0, NULL, 0, NULL, 2, img_barriers);
+
+    // Copy Y plane from each VkImage into libvmaf's device-local SSBO
+    VkBufferImageCopy region = {
+        .bufferOffset      = 0,
+        .bufferRowLength   = 0,   // tightly packed
+        .bufferImageHeight = 0,
+        .imageSubresource  = {
+            y_aspect, 0, 0, 1
+        },
+        .imageOffset = { 0, 0, 0 },
+        .imageExtent = { ref->width, ref->height, 1 },
+    };
+
+    vk->CmdCopyImageToBuffer(s->copy_cmd, ref_vk->img[0],
+                           VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
+                           s->vmaf_ref_buf, 1, &region);
+    vk->CmdCopyImageToBuffer(s->copy_cmd, dist_vk->img[0],
+                           VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
+                           s->vmaf_dist_buf, 1, &region);
+
+    // Make buffer writes visible to subsequent compute-shader reads
+    VkMemoryBarrier mem_barrier = {
+        .sType         = VK_STRUCTURE_TYPE_MEMORY_BARRIER,
+        .srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT,
+        .dstAccessMask = VK_ACCESS_SHADER_READ_BIT,
+    };
+    vk->CmdPipelineBarrier(s->copy_cmd,
+                         VK_PIPELINE_STAGE_TRANSFER_BIT,
+                         VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
+                         0, 1, &mem_barrier, 0, NULL, 0, NULL);
+
+    vk->EndCommandBuffer(s->copy_cmd);
+
+    // Submit: wait on both input timeline semaphores, signal dist's next value
+    VkSemaphore wait_sems[2]          = { ref_vk->sem[0], dist_vk->sem[0] };
+    uint64_t    wait_values[2]        = { ref_vk->sem_value[0],
+                                          dist_vk->sem_value[0] };
+    VkPipelineStageFlags wait_dst[2]  = { VK_PIPELINE_STAGE_TRANSFER_BIT,
+                                          VK_PIPELINE_STAGE_TRANSFER_BIT };
+    uint64_t    new_dist_val          = dist_vk->sem_value[0] + 1;
+    VkSemaphore signal_sems[1]        = { dist_vk->sem[0] };
+    uint64_t    signal_values[1]      = { new_dist_val };
+
+    VkTimelineSemaphoreSubmitInfo ts = {
+        .sType                     = VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO,
+        .waitSemaphoreValueCount   = 2,
+        .pWaitSemaphoreValues      = wait_values,
+        .signalSemaphoreValueCount = 1,
+        .pSignalSemaphoreValues    = signal_values,
+    };
+    VkSubmitInfo submit = {
+        .sType                = VK_STRUCTURE_TYPE_SUBMIT_INFO,
+        .pNext                = &ts,
+        .waitSemaphoreCount   = 2,
+        .pWaitSemaphores      = wait_sems,
+        .pWaitDstStageMask    = wait_dst,
+        .commandBufferCount   = 1,
+        .pCommandBuffers      = &s->copy_cmd,
+        .signalSemaphoreCount = 1,
+        .pSignalSemaphores    = signal_sems,
+    };
+
+    vr = vk->QueueSubmit(s->vk_queue, 1, &submit, VK_NULL_HANDLE);
+    if (vr != VK_SUCCESS) {
+        av_log(ctx, AV_LOG_ERROR, "vkQueueSubmit (Y copy) failed: %d\n", vr);
+        return AVERROR_EXTERNAL;
+    }
+    // No fence needed — copy and compute share the same queue, so Vulkan
+    // guarantees in-order execution.  The TRANSFER→COMPUTE memory barrier
+    // in copy_cmd handles data visibility.  vmaf_vulkan_wait_compute() at
+    // the start of the NEXT frame waits for batch_fence (signaled after
+    // compute submit), which implicitly covers this earlier copy submit.
+
+    // Update dist frame tracking for downstream consumers
+    dist_vk->layout[0]    = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
+    dist_vk->access[0]    = 0;
+    dist_vk->sem_value[0] = new_dist_val;
+
+    // Zero-copy submit: extractors read directly from shared buffers
+    ret = vmaf_read_pictures_vulkan(s->vmaf, s->frame_cnt++);
+    if (ret) {
+        av_log(ctx, AV_LOG_ERROR,
+               "vmaf_read_pictures_vulkan failed: %d\n", ret);
+        return AVERROR_EXTERNAL;
+    }
+
+    return ff_filter_frame(ctx->outputs[0], dist);
+}
+
+static av_cold int init_vulkan(AVFilterContext *ctx)
+{
+    LIBVMAFContext *s = ctx->priv;
+    s->fs.on_event = do_vmaf_vulkan;
+    return 0;
+}
+
+static av_cold void uninit_vulkan(AVFilterContext *ctx)
+{
+    LIBVMAFContext *s = ctx->priv;
+    FFVulkanFunctions *vk = &s->vkfn;
+    if (s->gpu_profile && s->vk_state) {
+        char *prof = vmaf_vulkan_profiling_get_string(s->vk_state);
+        if (prof) {
+            av_log(ctx, AV_LOG_INFO, "%s", prof);
+            free(prof);
+        }
+    }
+    if (s->vk_device && vk->DestroyCommandPool) {
+        if (s->copy_pool) {
+            vk->DestroyCommandPool(s->vk_device, s->copy_pool, NULL);
+            s->copy_pool = VK_NULL_HANDLE;
+        }
+    }
+    uninit(ctx);
+}
+
+static int config_props_vulkan(AVFilterLink *outlink)
+{
+    int err;
+    VkResult vr;
+    AVFilterContext *ctx = outlink->src;
+    LIBVMAFContext *s = ctx->priv;
+    AVFilterLink *inlink = ctx->inputs[0];
+    FilterLink *inl = ff_filter_link(inlink);
+    AVHWFramesContext *frames_ctx;
+    AVVulkanDeviceContext *vk_hwctx;
+    const AVPixFmtDescriptor *desc;
+    int queue_family = -1;
+
+    if (!inl->hw_frames_ctx) {
+        av_log(ctx, AV_LOG_ERROR,
+               "No Vulkan hw_frames_ctx on input. Use -hwaccel vulkan.\n");
+        return AVERROR(EINVAL);
+    }
+
+    frames_ctx = (AVHWFramesContext *)inl->hw_frames_ctx->data;
+    vk_hwctx = frames_ctx->device_ctx->hwctx;
+    desc = av_pix_fmt_desc_get(frames_ctx->sw_format);
+    s->bpc = desc->comp[0].depth;
+    s->pixel_shift = desc->comp[0].shift;
+
+    av_log(ctx, AV_LOG_INFO,
+           "libvmaf_vulkan: sw_format=%s bpc=%u pixel_shift=%u "
+           "comp[0]={depth=%d,shift=%d,step=%d,offset=%d} %dx%d\n",
+           desc->name, s->bpc, s->pixel_shift,
+           desc->comp[0].depth, desc->comp[0].shift,
+           desc->comp[0].step, desc->comp[0].offset,
+           inlink->w, inlink->h);
+
+    // Detect whether FFmpeg hwframes uses multi-planar VkImages or separate
+    // per-plane images.  For multi-planar images (single VkImage containing
+    // all planes), the Y plane must be addressed with PLANE_0_BIT, not
+    // COLOR_BIT.
+    {
+        AVVulkanFramesContext *vk_frames = frames_ctx->hwctx;
+        int nb_planes = av_pix_fmt_count_planes(frames_ctx->sw_format);
+        if (nb_planes > 1 && vk_frames->format[1] == VK_FORMAT_UNDEFINED) {
+            // Single multi-planar VkImage (e.g. G8_B8_R8_3PLANE_420_UNORM)
+            s->y_plane_aspect = VK_IMAGE_ASPECT_PLANE_0_BIT;
+        } else {
+            // Separate per-plane images, or single-plane format
+            s->y_plane_aspect = VK_IMAGE_ASPECT_COLOR_BIT;
+        }
+        av_log(ctx, AV_LOG_INFO,
+               "libvmaf_vulkan: Y-plane aspect=0x%x (%s) nb_planes=%d "
+               "fmt[0]=0x%x fmt[1]=0x%x\n",
+               s->y_plane_aspect,
+               (s->y_plane_aspect == VK_IMAGE_ASPECT_PLANE_0_BIT)
+                   ? "PLANE_0" : "COLOR",
+               nb_planes,
+               vk_frames->format[0], vk_frames->format[1]);
+    }
+
+    // Find a compute-capable queue family
+    for (int i = 0; i < vk_hwctx->nb_qf; i++) {
+        if (vk_hwctx->qf[i].flags & VK_QUEUE_COMPUTE_BIT) {
+            queue_family = vk_hwctx->qf[i].idx;
+            break;
+        }
+    }
+    if (queue_family < 0) {
+        av_log(ctx, AV_LOG_ERROR, "No compute queue family found.\n");
+        return AVERROR(EINVAL);
+    }
+
+    // Share FFmpeg's Vulkan device with libvmaf
+    VmafVulkanConfiguration vk_cfg = {
+        .vk_instance        = vk_hwctx->inst,
+        .vk_physical_device = vk_hwctx->phys_dev,
+        .vk_device          = vk_hwctx->act_dev,
+        .queue_family       = queue_family,
+        .queue_index        = 0,
+    };
+
+    VmafConfiguration cfg = {
+        .log_level = log_level_map(av_log_get_level()),
+        .n_subsample = s->n_subsample,
+        .n_threads = s->n_threads,
+    };
+
+    err = vmaf_init(&s->vmaf, cfg);
+    if (err)
+        return AVERROR(EINVAL);
+
+    err = vmaf_vulkan_state_init(&s->vk_state, vk_cfg);
+    if (err) {
+        av_log(ctx, AV_LOG_ERROR,
+               "vmaf_vulkan_state_init failed: %d\n", err);
+        return AVERROR_EXTERNAL;
+    }
+
+    if (s->gpu_profile) {
+        err = vmaf_vulkan_profiling_enable(s->vk_state);
+        if (err)
+            av_log(ctx, AV_LOG_WARNING,
+                   "GPU profiling not available on this device\n");
+    }
+
+    err = vmaf_vulkan_import_state(s->vmaf, s->vk_state);
+    if (err) {
+        av_log(ctx, AV_LOG_ERROR,
+               "vmaf_vulkan_import_state failed: %d\n", err);
+        return AVERROR_EXTERNAL;
+    }
+
+    // Zero-copy: allocate shared device-local buffers inside libvmaf,
+    // then export VkBuffer handles so we can vkCmdCopyImageToBuffer into them
+    err = vmaf_vulkan_init_frame_buffers(s->vmaf, inlink->w, inlink->h, s->bpc,
+                                         s->pixel_shift);
+    if (err) {
+        av_log(ctx, AV_LOG_ERROR,
+               "vmaf_vulkan_init_frame_buffers failed: %d\n", err);
+        return AVERROR_EXTERNAL;
+    }
+
+    VkBuffer ref_buf, dist_buf;
+    err = vmaf_vulkan_get_frame_buffers(s->vmaf, &ref_buf, &dist_buf,
+                                        NULL, NULL);
+    if (err) {
+        av_log(ctx, AV_LOG_ERROR,
+               "vmaf_vulkan_get_frame_buffers failed: %d\n", err);
+        return AVERROR_EXTERNAL;
+    }
+    s->vmaf_ref_buf  = ref_buf;
+    s->vmaf_dist_buf = dist_buf;
+    s->vk_device     = vk_hwctx->act_dev;
+
+    // Load Vulkan function pointers from FFmpeg's dynamic dispatch
+    err = ff_vk_load_functions(frames_ctx->device_ctx, &s->vkfn,
+                               0, 1, 1);
+    if (err < 0) {
+        av_log(ctx, AV_LOG_ERROR, "Failed to load Vulkan functions\n");
+        return err;
+    }
+    FFVulkanFunctions *vk = &s->vkfn;
+    vk->GetDeviceQueue(s->vk_device, queue_family, 0, &s->vk_queue);
+
+    // Command pool + buffer for the per-frame Y-plane copy
+    VkCommandPoolCreateInfo pool_info = {
+        .sType            = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,
+        .flags            = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT,
+        .queueFamilyIndex = queue_family,
+    };
+    vr = vk->CreateCommandPool(s->vk_device, &pool_info, NULL, &s->copy_pool);
+    if (vr != VK_SUCCESS) {
+        av_log(ctx, AV_LOG_ERROR, "vkCreateCommandPool failed: %d\n", vr);
+        return AVERROR_EXTERNAL;
+    }
+
+    VkCommandBufferAllocateInfo cmd_alloc = {
+        .sType              = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,
+        .commandPool        = s->copy_pool,
+        .level              = VK_COMMAND_BUFFER_LEVEL_PRIMARY,
+        .commandBufferCount = 1,
+    };
+    vr = vk->AllocateCommandBuffers(s->vk_device, &cmd_alloc, &s->copy_cmd);
+    if (vr != VK_SUCCESS) {
+        av_log(ctx, AV_LOG_ERROR, "vkAllocateCommandBuffers failed: %d\n", vr);
+        return AVERROR_EXTERNAL;
+    }
+
+    err = parse_models(ctx);
+    if (err)
+        return err;
+
+    err = parse_features(ctx);
+    if (err)
+        return err;
+
+    return config_output(outlink);
+}
+
+static const AVFilterPad libvmaf_outputs_vulkan[] = {
+    {
+        .name         = "default",
+        .type         = AVMEDIA_TYPE_VIDEO,
+        .config_props = config_props_vulkan,
+    },
+};
+
+const FFFilter ff_vf_libvmaf_vulkan = {
+    .p.name         = "libvmaf_vulkan",
+    .p.description  = NULL_IF_CONFIG_SMALL("Calculate the VMAF between two video "
+                                           "streams using Vulkan GPU acceleration."),
+    .p.priv_class   = &libvmaf_vulkan_class,
+    .preinit        = libvmaf_vulkan_framesync_preinit,
+    .init           = init_vulkan,
+    .uninit         = uninit_vulkan,
+    .activate       = activate,
+    .priv_size      = sizeof(LIBVMAFContext),
+    FILTER_INPUTS(libvmaf_inputs),
+    FILTER_OUTPUTS(libvmaf_outputs_vulkan),
+    FILTER_SINGLE_PIXFMT(AV_PIX_FMT_VULKAN),
+    .flags_internal = FF_FILTER_FLAG_HWFRAME_AWARE,
+};
+#endif
